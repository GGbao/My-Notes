

## Java多态原理

它允许基类的指针或引用指向派生类的对象，而在具体访问时实现方法的动态绑定。Java 对于方法调用动态绑定的实现主要依赖于方法表。

允许使用一个父类类型的变量来引用一个子类类型的对象，根据被引用子类对象特征的不同，得到不同的运行结果。

Java编译器将Java源代码编译成class文件，在编译过程中，会根据静态类型将调用的符号引用写到class文件中。在执行时，JVM根据class文件找到调用方法的符号引用，然后在静态类型的方法表中找到偏移量，然后根据this指针确定对象的实际类型，使用实际类型的方法表，偏移量跟静态类型中方法表的偏移量一样，如果在实际类型的方法表中找到该方法，则直接调用，否则，认为没有重写父类该方法。按照继承关系从下往上搜索。

## Java 中接口和抽象类的区别。

### 抽象类

抽象类必须用 `abstract` 修饰，子类必须实现抽象类中的抽象方法，如果有未实现的，那么子类也必须用 abstract 修饰。抽象类默认的权限修饰符为 `public`，可以定义为 public 或 procted，如果定义为 private，那么子类则无法继承。抽象类不能创建对象

### 接口

接口中的变量隐式的使用 `public static final` 修饰，并且需要给出初始值。方法隐式的使用 `public abstract` 修饰(并且只能是 public ，如果是 private，procted，那么就编译报错)。接口中的方法默认不能有具体的实现（JDK1.8开始可以有默认的实现）

1. 抽象类只能继承一次，但是可以实现多个接口
2. 接口和抽象类必须实现其中所有的方法，抽象类中如果有未实现的抽象方法，那么子类也需要定义为抽象类。抽象类中可以有非抽象的方法
3. 接口中的变量必须用 public static final 修饰，并且需要给出初始值。所以实现类不能重新定义，也不能改变其值。
4. 接口中的方法默认是 public abstract，也只能是这个类型。不能是 static，接口中的方法也不允许子类覆写，抽象类中允许有static 的方法

## 多线程的几种实现方式及使用Runnable接口的优势

**一、继承Thread类创建线程**：重写run方法，用start启动线程

**二、实现Runnable方法创建线程**：需要首先实例化一个Thread，并传入自己的实例

**三、实现Callable接口通过FutureTask包装器来创建Thread线程**

### **实现Runnable接口比继承Thread类所具有的优势：**

**（1）适合多个相同的程序代码的线程去处理同一个资源**

**（2）可以避免java中的单继承的限制**



## IOC容器：创建 Bean 容器，一个是初始化 Bean

- BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。

### refresh()

**创建 Bean 容器，加载并注册 Bean**

> ApplicationContext 继承自 BeanFactory，其内部持有一个实例化的BeanFactory（**DefaultListableBeanFactory**）。所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。

我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。

> BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。



- 通过BeanDefinitionReader 来加载配置（）XML、解析。将每一个配置文件转换为一颗 DOM 树了。
- 从根节点开始解析，比如：<import />`、`<alias />`、`<bean />`、`<beans />` 这几个。然后通过对标签解析转化为一个个 BeanDefinitionHolder 实例。这个实例里面包含了 **BeanDefinition 的实例**和它的 beanName、aliases 这三个信息。
- 然后注册这个 BeanDefinition，并且把这个注册事件发送出去。并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 `environment`、`systemProperties` 等。bean容器初始化完成。

**Bean 容器实例化完成后，创建 Bean的过程**

- 剩下的就是初始化 singleton beans ，我们经常用BeanFactory 中getBean(beanName) 方法获取一个 Bean，而初始化的过程也封装到了这个方法里。

> doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 

- createBeanInstance(...) 方法实现实例化，采用工厂方式实例化bean。
- 利用populateBean(...) 方法，来进行属性设值，处理依赖。
- 属性注入完成后，initializeBean()方法来处理各种回调。比如：

> // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调
>
> // BeanPostProcessor 的 postProcessBeforeInitialization 、postProcessAfterInitialization 的回调
>
> // 处理 bean 中定义的 init-method

![1595661978041](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1595661978041.png)

## Bean的-生命周期

- 1、实例化一个Bean－－也就是我们常说的new；
- 2、按照Spring上下文对实例化的Bean进行配置－－也就是IOC注入；
- 3、如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值
- 如果实现了BeanClassLodaerAware接口，调用setBeanClassLoader(),传入Class Loader对象实例。
- 其他Aware接口
- 4、如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；
- 5、如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口 ，有更多的实现方法）；
- 6、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用个的方法，也可以被应用于内存或缓存技术；
-  7、如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。
- 8、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法、；

​    注：以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。

- 9、当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；
- 10、最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。

## 在浏览器输入URL发生了什么？TCP三次握手以及四次挥手

### **1、DNS解析：将域名解析为IP地址;**

DNS解析的过程就是寻找哪台机器上有你需要资源的过程。DNS解析是一个递归查询的过程。我们的域名解析就是在 DNS 上记录一条信息记录。网页通过向DNS服务器发送域名，DNS服务器查询到与域名相应的IP地址，然后返回给浏览器。

### **2、TCP连接：TCP三次握手;**

**三次握手：**建立可靠的通信信道，就是双方确认自己与对方的发送与接收是正常的。

1、客户端–发送带有 SYN 标志2、服务端–发送带有 SYN/ACK 标志的数据包3、客户端–发送带有带有 ACK 标志的数据包。

### **3、发生HTTP请求;**

请求报文由请求行、请求头、请求体三部分组成：

**1.请求行包含请求方法、URL、协议版本**
请求方法包含 8 种：
GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。
URL 即请求地址，由 <协议>：//<主机>：<端口>/<路径>?<参数> 组成
协议版本即 http 版本号

```
POST /chapter17/user.html HTTP/1.1
“POST” 代表请求方式
“/chapter17/user.html”表示URL
"HTTP/1.1"代表协议和协议的版本。
```

**2.请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。**
请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：Host，表示主机名，虚拟主机；Connection,HTTP/1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent，请求发出者，兼容性以及定制化需求。

**3.请求体，可以承载多个请求参数的数据**，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。

```
name=tom&password=1234&realName=tomson
上面代码，承载着 name、password、realName 三个请求参数。
```

### 4、服务器处理请求并返回HTTP报文;

后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。 MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）-- 视图（view）–控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。

**1、视图（view）**：它是提供给用户的操作界面，是程序的外壳。
**2、模型（model）**：模型主要负责数据交互。在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。
**3、控制器（controller）**：它负责根据用户从"视图层"输入的指令，选取"模型层"中的数据，然后对其进行相应的操作，产生最终结果。

**http 响应报文**
响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。

(1) 响应行包含：协议版本，状态码，状态码描述
状态码规则如下：
1xx：指示信息–表示请求已接收，继续处理。
2xx：成功–表示请求已被成功接收、理解、接收。
3xx：重定向–要完成请求必须进行更进一步的操作。
4xx：客户端错误–请求有语法错误或请求无法实现。
5xx：服务器端错误–服务器未能实现合法的请求。

(2) 响应头部包含响应报文的附加信息，由 名/值 对组成

(3) 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据

### 5、浏览器解析渲染页面;

### 6、断开连接：TCP四次挥手;

**1、**客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送2、服务器-收到这个 FIN，它发回一个ACK，确认序号为收到的序号加1 。3、然后等待数据传输完，发送一个FIN给客户端4、客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1。

**2ms：**服务器已经发送了FIN+ACK报文请求断开了，客户端还没有给回应，发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。防止新的连接中出现旧连接的请求报文

## http1.0和http1.1之间有什么区别

**HTTP 1.0**规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。
**HTTP 1.1**则支持持久连接Persistent Connection, 并且默认使用persistent connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段).使用长连接的HTTP协议，会在响应头加入

```
Connection:keep-alive
```

## http和https的区别

Http：[超文本传输协议]最为广泛的一种[网络协议](https://baike.baidu.com/item/网络协议/328636)。是为了提供一种发布和接收[HTML](https://baike.baidu.com/item/HTML)页面的方法。

1、https协议需要申请证书。

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

### Https原理 

HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP的协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。

### Https非对称加密具体处理流程 

一个HTTPS请求实际上包含了两次HTTP传输。
 1.客户端向服务器发起HTTPS请求，连接到服务器的443端口

2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥。

3.服务器可以将自己的公钥以及证书发送给客户端。

4.客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，即客户端密钥。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。

5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。

6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对要响应的数据进行对称加密，这样数据就变成了密文。

7.然后服务器将加密后的密文发送给客户端。

8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。

## 进程的有哪几种状态，状态转换图，及导致转换的事件

![img](https://img-blog.csdn.net/20140806162319890)

  注意：创建和退出不是进程的状态。阻塞和就绪的区别：阻塞是等待除CPU以外的资源，而就绪等待的是CPU资源。

1）就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；
2）执行——阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等； 
3）阻塞——就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；
4）执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。

## 数据库三范式

 **1、表中的列只能含有原子性(不可再分)的值。**

**2、对记录的惟一性，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；**

**3、对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；**



## 斐波那契数列

O(2^n)

```
// 递归法(21ms,代码少，效率低)
public int fib(int N) {
    if (N == 0 || N == 1) {
        return N;
    }
    return fib(N - 1) + fib(N - 2);
}
// 数组法(1ms,要操作数组,效率比操作整型低一点)
public int fib(int N) {
    assert N > -1;
    if (N == 0 || N == 1) {
        return N;
    }
    int [] arr = new int[N + 1];
    arr[0] = 0;
    arr[1] = 1;
    for (int i = 2; i <= N; i++) {
        arr [i] = arr[i-2] + arr[i-1];
    }
    return arr[N];
}
// 替换法(0ms,效率最高,内存消耗都差不多)
public int fib(int N) {
    if (N == 0 || N == 1) {
        return N;
    }
    int x = 0,y = 1,z = 1,i = 0,end = N-2;
    while (i <= end) {
        z = x + y;
        x = y;
        y = z;
        i++;
    }
    return z;
}
```



## 48. 最长不含重复字符的子字符串

**请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。**

```java
    public int lengthOfLongestSubstring(String s) {
    
        int len = s.length();
        int left = 0;
        int max = 0;
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < len; i++) {
            if (map.containsKey(s.charAt(i))) {
                left = Math.max(left, map.get(s.charAt(i)));
            }
            map.put(s.charAt(i), i+1);//所以这里最好value计算为值的后一个index
            max = Math.max(max, i - left+1 );//比较的时候是i 和 left距离
        }
        return max;
    
    }
```

## 1、两数之和

- 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
      你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

```
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> tracker = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++) {
            if (!tracker.containsKey(nums[i])) {
                tracker.put(target - nums[i], i);
            } else {
                int left = tracker.get(nums[i]);
                return new int[]{left, i};
            }
        }
        return new int[2];
```

## 2、两数之和

- 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

```
public static class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode pre = new ListNode(0);
        ListNode cur = pre;
        int carry = 0;
        while (l1 != null || l2 != null) {
            int x = l1 == null ? 0 : l1.val;
            int y = l2 == null ? 0 : l2.val;
            int sum = x + y + carry;
            carry = sum / 10;
            sum = sum % 10;
            cur.next = new ListNode(sum);
            cur = cur.next;
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
        if (carry == 1) {
            cur.next = new ListNode(carry);
        }
        return pre;
    }
```

## 3. 无重复字符的最长子串(滑块窗口)

- 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

```
public int lengthOfLongestSubstring(String s) {
        int n = s.length(), max = 0, left = 0;
        Map<Character, Integer> map = new HashMap<>();
        for (int end = 0; end < n; end++) {
            if (map.containsKey(s.charAt(end))) {
                left = Math.max(left, map.get(s.charAt(end)));
            }
            map.put(s.charAt(end), end + 1);
            max = Math.max(end - left + 1, max);
        }
        return max;
    }
```

## ABC多线程打印

```
public static Lock lock = new ReentrantLock();
    public static int state = 0;

    static class myThread1 extends Thread {
        public void run() {
            for (int i = 0; i < 10; ) {
                try {
                    lock.lock();
                    while (state % 3 == 0) {
                        System.out.println("a");
                        i++;
                        state++;
                    }
                } finally {
                    lock.unlock();
                }
            }
        }

    }

    static class myThread2 extends Thread {
        public void run() {
            for (int i = state; i < 10; ) {
                try {
                    lock.lock();
                    while (state % 3 == 1) {
                        System.out.println("l");
                        i++;
                        state++;
                    }
                } finally {
                    lock.unlock();
                }
            }
        }

    }

    static class myThread3 extends Thread {
        public void run() {
            for (int i = state; i < 10; ) {
                try {
                    lock.lock();
                    while (state % 3 == 2) {
                        System.out.println("i");
                        i++;
                        state++;
                    }
                } finally {
                    lock.unlock();
                }
            }
        }

    }

    public static void main(String[] args) {

        new myThread1().start();
        new myThread2().start();
        new myThread3().start();
    }
```

## AB并发，完成后执行C

### CountDownLatch+Semaphore

```
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Semaphore;

public class TestABC {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch=new CountDownLatch(2);
        Semaphore semaphoreC = new Semaphore(1);
        
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(newjava.util.Random().nextInt(1000));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());
                //将count值减1
                countDownLatch.countDown();
            }
        }, "Thread-A");

        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(newjava.util.Random().nextInt(1000));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());
                countDownLatch.countDown();
            }
        }, "Thread-B");

        Thread threadC = new Thread(new Runnable() {
            @Override
            public void run() {                
                try {
                    semaphoreC.acquire();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());
                semaphoreC.release();
            }
        }, "Thread-C");
        
        // 占用C锁，直到A/B线程完成后，才释放C锁。
        semaphoreC.acquire();
        
        threadA.start();
        threadB.start();
        threadC.start();
        //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
        countDownLatch.await(); 
        // 释放C锁，让C线程有获取锁的可能
        semaphoreC.release();
        
    }
}
```

**不阻塞方法**

```
import java.util.concurrent.CountDownLatch;

public class TestABC {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch=new CountDownLatch(2);
        
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(new java.util.Random().nextInt(1000));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());
                countDownLatch.countDown();
            }
        }, "Thread-A");

        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(new java.util.Random().nextInt(1000));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());
                countDownLatch.countDown();
            }
        }, "Thread-B");

        Thread threadC = new Thread(new Runnable() {
            @Override
            public void run() {    
                // 在C中等待A/B運算結束
                try {
                    countDownLatch.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    throw new RuntimeException("CountDownLatch等待失败。。。",e);
                } 
                
                System.out.println(Thread.currentThread().getName());
            }
        }, "Thread-C");
        
        threadA.start();
        threadB.start();
        threadC.start();        
    }
}
```

### CyclicBarrier

```
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class TestABC {
    public static void main(String[] args) throws InterruptedException {
        CyclicBarrier cyclicBarrier=new CyclicBarrier(3);
        
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(new java.util.Random().nextInt(1000));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());

                // 冲破栅栏代表A线程结束
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                    throw new RuntimeException("cylicBarrier.await()拋出異常：",e);
                }
            }
        }, "Thread-A");

        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(new java.util.Random().nextInt(1000));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());
                
                // 冲破栅栏代表B线程结束
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                    throw new RuntimeException("cylicBarrier.await()拋出異常：",e);
                }
            }
        }, "Thread-B");

        Thread threadC = new Thread(new Runnable() {
            @Override
            public void run() {
                // 等待前两个(A/B)线程结束，只有前两个(A/B)线程结束了才能满足3个线程都冲破栅栏，
                try {
                    // 等待栅栏被冲破，冲破栅栏的条件是：A/B/C三个线程都到达await()。
                    // 只有栅栏冲破，才能向下执行，否则先到达的线程等待。
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                    throw new RuntimeException("cylicBarrier.await()拋出異常：",e);
                }
                // 满足了三个线程都冲破栅栏才向下执行
                System.out.println(Thread.currentThread().getName());
            }
        }, "Thread-C");
        
        threadA.start();
        threadB.start();
        threadC.start();        
    }
}
```



## 25.K 个一组翻转链表

- 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

  k 是一个正整数，它的值小于或等于链表的长度。

  如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。


```java
public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0), prev = dummy, curr = head, next;
        dummy.next = head;
        int length = 0;
        while(head != null) {
            length++;
            head = head.next;
        }
        head = dummy.next;
        for(int i = 0; i < length / k; i++) {
            for(int j = 0; j < k - 1; j++) {
                next = curr.next;
                curr.next = next.next;
                next.next = prev.next;
                prev.next = next;
            }
            prev = curr;
            curr = prev.next;
        }
        return dummy.next;
    }
```

## 121.买卖股票的最佳时机

- 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

  如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

  ```java
  public int maxProfit(int[] prices) {
          if(prices.length <= 1)
              return 0;
          int min = prices[0], max = 0;
          for(int i = 1; i < prices.length; i++) {
              max = Math.max(max, prices[i] - min);
              min = Math.min(min, prices[i]);
          }
          return max;
      }
  ```

  

## 15.三数之和

- 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

  ```
  public List<List<Integer>> threeSum(int[] nums) {
          
          List<List<Integer>> nlist = new ArrayList<>();
          Arrays.sort(nums);
          for (int i = 0; i < nums.length - 2; i++) {
              if (nums[i] > 0) {
                  break;
              }
              if (i > 0 && nums[i] == nums[i - 1]) {
                  continue;
              }
              int j = i + 1;
              int k = nums.length - 1;
              while (j < k) {
  
                  if (nums[j] + nums[k] < -nums[i]) {
                      j++;
                  } else if (nums[j] + nums[k] > -nums[i]) {
                      k--;
                  } else {
                      List<Integer> list = new ArrayList<>();
                      list.add(nums[i]);
                      list.add(nums[j]);
                      list.add(nums[k]);
                      nlist.add(list);
                      j++;
                      k--;
                      while (j < k && nums[j] == nums[j - 1]) {
                          j++;
                      }
                      while (j < k && k != nums.length - 1 && nums[k] == nums[k + 1]) {
                          k--;
                      }
                  }
              }
          }
          return nlist;
      }
  ```

## 155.最小栈

- 设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

```java
public class MinStack {
    // 数据栈
    private Stack<Integer> data;
    // 辅助栈
    private Stack<Integer> helper;
    /**
     * initialize your data structure here.
     */
    public MinStack() {
        data = new Stack<>();
        helper = new Stack<>();
    }

    // 思路 1：数据栈和辅助栈在任何时候都同步

    public void push(int x) {
        // 数据栈和辅助栈一定会增加元素
        data.add(x);
        if (helper.isEmpty() || helper.peek() >= x) {
            helper.add(x);
        } else {
            helper.add(helper.peek());
        }
    }

    public void pop() {
        // 两个栈都得 pop
        if (!data.isEmpty()) {
            helper.pop();
            data.pop();
        }
    }

    public int top() {
        if(!data.isEmpty()){
            return data.peek();
        }
        throw new RuntimeException("栈中元素为空，此操作非法");
    }

    public int getMin() {
        if(!helper.isEmpty()){
            return helper.peek();
        }
        throw new RuntimeException("栈中元素为空，此操作非法");
    }

```

## 124. 二叉树中的最大路径和

- 给定一个**非空**二叉树，返回其最大路径和。

  本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径**至少包含一个**节点，且不一定经过根节点。

```java
private int ret = Integer.MIN_VALUE;
    
    public int maxPathSum(TreeNode root) {
        /**
        对于任意一个节点, 如果最大和路径包含该节点, 那么只可能是两种情况:
        1. 其左右子树中所构成的和路径值较大的那个加上该节点的值后向父节点回溯构成最大路径
        2. 左右子树都在最大路径中, 加上该节点的值构成了最终的最大路径
        **/
        getMax(root);
        return ret;
    }
    
    private int getMax(TreeNode r) {
        if(r == null) return 0;
        int left = Math.max(0, getMax(r.left)); // 如果子树路径和为负则应当置0表示最大路径不包含子树
        int right = Math.max(0, getMax(r.right));
        ret = Math.max(ret, r.val + left + right); // 判断在该节点包含左右子树的路径和是否大于当前最大路径和
        return Math.max(left, right) + r.val;
    }
```

## 199. 二叉树的右视图

- 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

```java
 public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
                if (i == size - 1) {  //将当前层的最后一个节点放入结果列表
                    res.add(node.val);
                }
            }
        }
        return res;
    }
```

## 3. 无重复字符的最长子串

- 给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

```
public int lengthOfLongestSubstring(String s) {
        // 记录字符上一次出现的位置
        int[] last = new int[128];
        for(int i = 0; i < 128; i++) {
            last[i] = -1;
        }
        int n = s.length();

        int res = 0;
        int start = 0; // 窗口开始位置
        for(int i = 0; i < n; i++) {
            int index = s.charAt(i);
            start = Math.max(start, last[index] + 1);
            res   = Math.max(res, i - start + 1);
            last[index] = i;
        }

        return res;
    }
```

## 88. 合并两个有序数组

给你两个有序整数数组 *nums1* 和 *nums2*，请你将 *nums2* 合并到 *nums1* 中*，*使 *nums1* 成为一个有序数组。

```
public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index = m + n - 1;
        if (m == 0) {
            for (int i = 0; i <= index; i++) {
                nums1[i] = nums2[i];
            }
        }

        while (n > 0 && index >= 0&&m > 0) {
            if (nums1[m - 1] <= nums2[n - 1]) {
                nums1[index--] = nums2[--n];
            } else {
                nums1[index--] = nums1[--m];
            }
        }
        while (n > 0) {
            nums1[index--] = nums2[--n];
        }
        
    }
```

## 108. 将有序数组转换为二叉搜索树

- 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

  本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。

```
public TreeNode sortedArrayToBST(int[] nums) {
        return sortedArrayToBST(nums, 0, nums.length-1);
    }

    private TreeNode sortedArrayToBST(int[] nums, int start, int end) {
        if (start > end) {
            return null;
        }
        int mid =  start + ( end - start ) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = sortedArrayToBST(nums, start, mid-1);
        root.right = sortedArrayToBST(nums, mid + 1, end);
        return root;
    }
```

## 110. 平衡二叉树

- 给定一个二叉树，判断它是否是高度平衡的二叉树。

  本题中，一棵高度平衡二叉树定义为：一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过1。

```
boolean isBalanced = true;
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        treeDepth(root);
        return isBalanced;
        
    }

    private int treeDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = treeDepth(root.left);
        int right = treeDepth(root.right);
        if (left - right > 1 || right - left > 1) {
            isBalanced = false;
        }
        return Math.max(left, right)+1;
    }
```

## 236. 二叉树的最近公共祖先

- 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

```
public class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode(int x) { val = x; }
  }
  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // LCA 问题
        if (root == null) {
            return root;
        }
        if (root == p || root == q) {
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left != null && right != null) {
            return root;
        } else if (left != null) {
            return left;
        } else if (right != null) {
            return right;
        }
        return null;
    }
  
```

## 33. 搜索旋转排序数组

- 设按照升序排序的数组在预先未知的某个点上进行了旋转。

  ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

  搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。


```
public int search(int[] nums, int target) {
         if (nums == null || nums.length == 0) {
                return -1;
            }
            int start = 0;
            int end = nums.length - 1;
            int mid;
            while (start <= end) {
                mid = start + (end - start) / 2;
                if (nums[mid] == target) {
                    return mid;
                }
                if (nums[mid] >= nums[end]) {
                    //前半部分有序
                    if (target >= nums[start] && target <= nums[mid]) {
                        end = mid - 1;
                    } else {
                        start = mid + 1;
                    }

                } else {
                    //后半段有序
                    if (target >= nums[mid] && target <= nums[end]) {
                        start = mid + 1;
                    } else {
                        end = mid - 1;
                    }
                }
            }
            return -1;
    }
```

## 322. 零钱兑换

- 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。


```
public int coinChange(int[] coins, int amount) {
        // 自底向上的动态规划
        if(coins.length == 0){
            return -1;
        }

        // dp[n]的值： 表示的凑成总金额为n所需的最少的硬币个数
        int[] dp = new int[amount+1];
        dp[0] = 0;
        for(int i = 1; i <= amount;i++){
            int min = Integer.MAX_VALUE;
            for(int j = 0;j < coins.length;j++){
                if(i - coins[j] >= 0 && dp[i-coins[j]] < min){
                    min = dp[i-coins[j]] + 1;
                }
            }
            // dp[i] = (min == Integer.MAX_VALUE ? Integer.MAX_VALUE : min);
            dp[i] = min;
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }

```

## 83. 删除排序链表中的重复元素

- 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

```
public ListNode deleteDuplicates(ListNode head) {
        ListNode pre = new ListNode(-1000);
        pre.next = head;
        ListNode slow = pre;
        ListNode fast = pre.next;
        while (slow.next != null) {
            if (slow.val != fast.val) {
                slow = fast;
                fast = fast.next;
            } else {
                fast = fast.next;
            }
            slow.next = fast;
        }
        return pre.next;
    }
```

## 206. 反转链表

```
public static ListNode reverseListIterative(ListNode head) {
        ListNode prev = null; //前指针节点
        ListNode curr = head; //当前指针节点
        //每次循环，都将当前节点指向它前面的节点，然后当前节点和前节点后移
        while (curr != null) {
            ListNode nextTemp = curr.next; //临时节点，暂存当前节点的下一节点，用于后移
            curr.next = prev; //将当前节点指向它前面的节点
            prev = curr; //前指针后移
            curr = nextTemp; //当前指针后移
        }
        return prev;
```

## 215. 数组中的第K个最大元素

```
public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int left = 0;
        int right = len - 1;
        //转换一下，第 k 大元素的索引是 len - k
        int target = len - k;
        while (true) {
            int index = partition(nums, left, right);
            if (index == target) {
                return nums[index];
            } else if (index > target) {
                right = index - 1;
            } else {
                left = index + 1;
            }
        }
    }
    private int partition(int[] array, int l, int r) {
        int temp = array[l];
        while (l < r) {
            while (l < r && temp <= array[r]) {
                r--;
            }
            if (l < r) {
                array[l++] = array[r];
            }
            while (l < r && temp >= array[l]) {
                l++;
            }
            if (l < r) {
                array[r--] = array[l];
            }
        }
        array[l] = temp;
        return l;
    }
```

## 56. 合并区间

- 给出一个区间的集合，请合并所有重叠的区间。

```
public int[][] merge(int[][] intervals) {
        if (intervals == null||intervals.length==0) {
            return new int[0][];
        }
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0]-o2[0];
            }
        });
      int len = intervals.length;
        LinkedList<int[]> res = new LinkedList<>();
        res.add(intervals[0]);
        for (int i = 1; i < len; i++) {
            int[] last = res.getLast();
            int left = intervals[i][0];
            int right = intervals[i][1];
            if (left > last[1]) {
                res.add(intervals[i]);
            }else if (left < last[0]) {
                last[0] = left;
                if(right>last[1]){
                    last[1]=right;
                }
            }
            else if (left <= last[1]&&right>last[1]) {
                last[1] = right;
            }
        }
       return res.toArray(new int[0][]);
    }
```

## 146. LRU缓存机制

- 运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

  获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。
  写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

  ```
  class LRUCache {
      Queue<Integer> queue;
      Map<Integer, Integer> map;
      int capacity;
      public LRUCache(int capacity) {
          this.map = new HashMap<>();
          this.queue = new LinkedList<>();
          this.capacity = capacity;
      }
      
      public int get(int key) {
          if (queue.contains(key))
          {
              queue.remove(key);
              queue.add(key);
              return map.get(key);
          }
          else
          {
              return -1;
          }
      }
      
      public void put(int key, int value) {
          if (queue.contains(key))
          {
              queue.remove(key);
              queue.add(key);
              map.put(key, value);
          }
          else if (capacity == 0)
          {
              map.remove(queue.poll());
              queue.add(key);
              map.put(key, value);
          }
          else
          {
              queue.add(key);
              map.put(key, value);
              capacity--;
          }
      }
  }
  ```

  

## 102. 二叉树的层序遍历

```
	public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
	List<List<Integer>> res_102 = new ArrayList<>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return res_102;
        }
        Deque<TreeNode> deque = new ArrayDeque<>();
        TreeNode front = null;
        deque.add(root);
        while (!deque.isEmpty()) {
            List<Integer> list = new ArrayList<>();
            //每一层的个数
            for (int i = deque.size(); i > 0; i--) {
                front = deque.poll();
                list.add(front.val);
                if (front.left != null) {
                    deque.add(front.left);
                }
                if (front.right != null) {
                    deque.add(front.right);
                }
            }
            res_102.add(list);
        }
        return res_102;
    }
```

## 518. 零钱兑换 II

- 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

- dp [i] [j]表示金额为j的情况下，对于前i种，最多有多少种组合。

- 接下来就是状态转移。

  如果我们不选择当前第i个面额，组合的数目为dp [i-1] [j]
  如果我们选择当前当前第i个面额，那么dp[i-1] [j-coins[i-1]]
  那么当前的组合数目应该是选择不选择都放到一起的。

  dp[i] [j] = dp[i-1] [j] + dp[i-1] [j-coins[i-1]]

```
public int change(int amount, int[] coins) {
        int[][] dp = new int[coins.length+1][amount+1];
        //明确base case  在金额为0的情况下,不管是任何***，只能有一种组合（也就是什么***都不用这种组合）
        for(int i = 0; i<coins.length+1; i++) dp[i][0] = 1;
        for(int i = 1; i < coins.length+1; i++){
            for(int j = 1; j<amount+1; j++){
                //如果当前的金额比***面值小，那只能选择不放，继承之前的状态了
                if(j < coins[i-1]) dp[i][j] = dp[i-1][j];
                //当前的组合数目应该是选择不选择都放到一起的
                else{
                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];
                }
            }
        }
        return dp[coins.length][amount];
    }

```

## 用两个栈实现队列

- 加入队尾 appendTail()函数： 将数字 val 加入栈 A 即可。
  删除队首deleteHead()函数： 有以下三种情况。
  当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。
  否则，当 A 为空： 即两个栈都为空，无元素，因此返回 -1−1 。
  否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。

```
class CQueue {

        public CQueue() {

        }

        Stack<Integer> a = new Stack<>();
        Stack<Integer> b = new Stack<>();


        public void appendTail(int value) {
            a.push(value);
        }

        public int deleteHead() {
            if (b.empty()) {
                if (a.empty()) {
                    return -1;
                }
                while (!a.empty()) {
                    b.push(a.pop());
                }
            }
            return b.pop();

        }
    }
```

## 54. 螺旋矩阵

```
public List<Integer> spiralOrder(int[][] matrix) {
        List ans = new ArrayList();
        if (matrix.length == 0) {
            return ans;
        }
        int R = matrix.length;
        int C = matrix[0].length;
        boolean[][] seen = new boolean[R][C];
        int[] dr = {0, 1, 0, -1};//游标移动方向控制
        int[] dc = {1, 0, -1, 0};
        int r = 0, c = 0, di = 0;
        for (int i = 0; i < R * C; i++) {
            ans.add(matrix[r][c]);
            seen[r][c] = true;
            int cr = r + dr[di];
            int cc = c + dc[di];
            if (cr >= 0 && cc >= 0 && cr < R && cc < C && !seen[cr][cc]) {
                r = cr;
                c = cc;
            } else {
                di = (di + 1) % 4;
                r += dr[di];
                c += dc[di];
            }

        }
        return ans;
    }
```

## 1299.将每个元素替换为右侧最大元素

- 给你一个数组 `arr` ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 `-1` 替换。

```
public int[] replaceElements(int[] arr) {
        int max = -1;
        for (int i = arr.length - 1; i >= 0; i--) {
            int temp = arr[i];
            arr[i] = max;
            if (temp > max) {
                max = temp;
            }
        }
        return arr;
    }
```

## 42.接雨水

- 给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```
public int trap(int[] height) {
        int min = 0 , max = 0 ;
        int l = 0, r = height.length-1;
        
        int res = 0;
        while(l < r){
            min = height[height[l] < height[r] ? l++:r--];
            max = Math.max(min,max);
            res += max - min;
        }
        return res;
    }
```

## 105. 从前序与中序遍历序列构造二叉树

```
int[] preOrd;
    HashMap<Integer, Integer> dic = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        preOrd = preorder;
        for (int i = 0; i < inorder.length; i++) {
            dic.put(inorder[i], i);
        }
        return rebuild(0, 0, inorder.length - 1);
    }

    /**
     *
     * @param pre_root 前序遍历中根节点的索引
     * @param in_left  中序遍历左边界
     * @param in_right 中序遍历右边界
     * @return
     */
    private TreeNode rebuild(int pre_root, int in_left, int in_right) {
        if (in_left > in_right) {
            return null;
        }
        //找出头节点
        TreeNode root = new TreeNode(preOrd[pre_root]);
        //找出头节点在中序中的索引位置
        int i = dic.get(preOrd[pre_root]);
        root.left = rebuild(pre_root + 1, in_left, i-1);
        root.right = rebuild(pre_root + (i - in_left + 1), i + 1, in_right);
        return root;
    }
```

## 160. 相交链表

- 编写一个程序，找到两个单链表相交的起始节点。

```
public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        /**
        定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)
        两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度
        **/
        if(headA == null || headB == null) return null;
        ListNode pA = headA, pB = headB;
        // 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null
        while(pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
```

## 139 单词拆分

- 给定一个**非空**字符串 *s* 和一个包含**非空**单词列表的字典 *wordDict*，判定 *s* 是否可以被空格拆分为一个或多个在字典中出现的单词。

```
public boolean wordBreak(String s, List<String> wordDict) {
        // 可以类比于背包问题
        int n = s.length();
        // memo[i] 表示 s 中以 i - 1 结尾的字符串是否可被 wordDict 拆分
        boolean[] memo = new boolean[n + 1];
        memo[0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                if (memo[j] && wordDict.contains(s.substring(j, i))) {
                    memo[i] = true;
                    break;
                }
            }
        }
        return memo[n];
    }
```

## 67. 二进制求和

- 给你两个二进制字符串，返回它们的和（用二进制表示）。

  输入为 **非空** 字符串且只包含数字 `1` 和 `0`。

```
public String addBinary(String a, String b) {
        StringBuffer sb = new StringBuffer();
        //两个数都从最后一位向前加
        int carry = 0, i = a.length()-1, j = b.length()-1;
        while(i >= 0 || j >= 0 || carry != 0){
            //如果是“0”没用，是“1”，+1
            if(i >= 0) carry += a.charAt(i--)-'0';
            if(j >= 0) carry += b.charAt(j--)-'0';
            //当前这位2进制下的求余数
            sb.append(carry%2);
            //是否进位，只有0,1,2这三种
            carry /= 2;
        }
        return sb.reverse().toString();
    }

```

## 230.二叉搜索树中第K小的元素

```
public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
class Solution {
    /**
     * 查找左子树节点个数为leftN,如果K<=leftN,则所查找节点在左子树上.
     * 若K=leftN+1,则所查找节点为根节点
     * 若K>leftN+1,则所查找节点在右子树上,按照同样方法查找右子树第K-leftN个节点
     * @param root
     * @param k
     * @return
     */
    public int kthSmallest(TreeNode root, int k) {
        int leftN=findChild(root.left);
        if(leftN+1==k) return root.val;
        else if(k<=leftN){
            return kthSmallest(root.left, k);
        }
        else return kthSmallest(root.right, k-leftN-1);
    }
    /**
     *查找子节点个数
     * @param root
     * @return
     */
    public int findChild(TreeNode root){
        if(root==null) return 0;
        return findChild(root.left)+findChild(root.right)+1;
    }
}
```

## 70. 爬楼梯

```
 public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0]=1;
        dp[1] = 1;
        
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
```

## 剑指 Offer 61. 扑克牌中的顺子

```
public boolean isStraight(int[] nums) {
        Arrays.sort(nums);
        int numZero = 0;
        int numGap = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) {
                numZero++;
            }
        }
        int small = numZero;
        int big = numZero + 1;
        while (big < nums.length) {
            if (nums[small] == nums[big]) {
                return false;
            }
            numGap += nums[big++] - nums[small++] - 1;
        }
        if (numZero >= numGap) {
            return true;
        }
        return false;
    }
```

## 543. 二叉树的直径

```
int max = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        if (root != null) {
            //遍历每一个节点,求出此节点作为根的树的深度,那么,左子树深度加右子树深度的最大值即是答案
            setDepth(root);
            return max;
        }
        return 0;
    }

    public int setDepth(TreeNode root) {
        if (root != null) {
            int right = setDepth(root.right);
            int left = setDepth(root.left);
            if (right + left > max)
                max = right + left;
            return Math.max(right, left) + 1;
        }
        return 0;
    }
```

## 112. 路径总和

- 定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

```
public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        // 如果是叶子结点，则看该结点值是否等于剩下的 sum
        if (root.left == null && root.right == null) {
            return sum == root.val;
        }
        // 每次遍历一个结点都要减去自己的值后重新递归
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
```

## 23. 合并K个排序链表

- 用容量为K的最小堆优先队列，把链表的头结点都放进去，然后出队当前优先队列中最小的，挂上链表，，然后让出队的那个节点的下一个入队，再出队当前优先队列中最小的，直到优先队列为空。

```
public ListNode mergeKLists(ListNode[] lists) {

        if (lists.length == 0) {
            return null;
        }

        ListNode dummyHead = new ListNode(0);
        ListNode curr = dummyHead;
        PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
            @Override
            public int compare(ListNode o1, ListNode o2) {
                return o1.val - o2.val;
            }
        });

        for (ListNode list : lists) {
            if (list == null) {
                continue;
            }
            pq.add(list);
        }

        while (!pq.isEmpty()) {
            ListNode nextNode = pq.poll();
            curr.next = nextNode;
            curr = curr.next;
            if (nextNode.next != null) {
                pq.add(nextNode.next);
            }
        }
        return dummyHead.next;
    }
```

## 2. 两数相加

- 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

  如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

  您可以假设除了数字 0 之外，这两个数都不会以 0 开头。


```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode pre = new ListNode(0);
        ListNode cur = pre;
        int carry = 0;
        while (l1 != null || l2 != null) {
            int x = l1 == null ? 0 : l1.val;
            int y = l2 == null ? 0 : l2.val;
            int sum = x + y + carry;
            carry = sum / 10;
            sum = sum % 10;
            cur.next = new ListNode(sum);
            cur = cur.next;
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
        if (carry == 1) {
            cur.next = new ListNode(carry);
        }
        return pre.next;
    }
}
```

## 3无重复的最长字符串长度

- 给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度

```
public int lengthOfLongestSubstring(String s) {
         int n = s.length(), max = 0,left=0;
        Map<Character, Integer> map = new HashMap<>();
        for (int end = 0; end < n; end++) {
            if (map.containsKey(s.charAt(end))) {
                left = Math.max(left, map.get(s.charAt(end)));
            }
            map.put(s.charAt(end), end + 1);
            max = Math.max(end - left + 1, max);
        }
        return max;
    }
```

## 141. 环形链表

- 给定一个链表，判断链表中是否有环。

  为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。


- java双指针 fast一次走两个，slow走一个，当两个相遇则有环

```
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null)   return false;
        ListNode fast = head.next;
        ListNode slow = head;
        while(fast != slow){
            if(fast.next == null || fast.next.next == null)   return false;
            fast = fast.next.next;
            slow = slow.next;
        }
        return true;
    }
}
```

## 515. 在每个树行中找最大值

- 您需要在二叉树的每一行中找到最大的值。

```
public List<Integer> largestValues(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if(root == null) {
            return ans;
        }
        Deque<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            int size = queue.size();
            int max = Integer.MIN_VALUE;
            for(int i = 0; i < size; i++) {
                TreeNode t = queue.poll();
                max = Math.max(t.val, max);
                if(t.left != null) {
                    queue.offer(t.left);
                }
                if(t.right != null) {
                    queue.offer(t.right);
                }
            }
            ans.add(max);
        }
        return ans;
    }
```

## 31. 下一个排列

```
 //源于离散数学及其应用的算法：（以3 4 5 2 1 为例）
    //从后往前寻找第一次出现的正序对：（找到 4,5）
    //之后因为从5 开始都是逆序，所以把他们反转就是正序：3 4 1 2 5
    //之后4 的位置应该是：在它之后的，比他大的最小值（5）
    //交换这两个值：得到 3 5 1 2 4
    // 对于初始即为逆序的序列，将在反转步骤直接完成
    public void nextPermutation(int[] nums) {
        int len = nums.length;
        if(len < 2) return;
        int i = len -1;
        while(i>0 && nums[i-1]>=nums[i]){    //从后向前找第一个正序，这里最后i指向的是逆序起始位置
            i--;
        }
        reverse(nums,i,len-1);  //翻转后面的逆序区域，使其变为正序
        if(i==0) return;
        int j = i-1; 
        while(i<len && nums[j]>=nums[i]){  //找到第一个比nums[j]大的元素，交换即可
            i++;
        }
        int temp = nums[j];
        nums[j] = nums[i];
        nums[i] = temp;
    }
    private void reverse(int[] nums, int start, int end){   //翻转数组
        while(start<end){
            int temp = nums[end];
            nums[end] = nums[start];
            nums[start] = temp;
            start++;
            end--;
        }
    }
```

## 297. 二叉树的序列化与反序列化

```
public class Codec {

    public String serialize(TreeNode root) {      //用StringBuilder
        StringBuilder res = ser_help(root, new StringBuilder());
        return res.toString();
    }
    
    public StringBuilder ser_help(TreeNode root, StringBuilder str){
        if(null == root){
            str.append("null,");
            return str;
        }
        str.append(root.val); 
        str.append(",");
        str = ser_help(root.left, str);
        str = ser_help(root.right, str);
        return str;
    }

    public TreeNode deserialize(String data) {
        String[] str_word = data.split(",");
        List<String> list_word = new LinkedList<String>(Arrays.asList(str_word));
        return deser_help(list_word);
    }
    
    public TreeNode deser_help(List<String> li){
        if(li.get(0).equals("null")){
            li.remove(0);
            return null;
        }
        TreeNode res = new TreeNode(Integer.valueOf(li.get(0)));
        li.remove(0);
        res.left = deser_help(li);
        res.right = deser_help(li);
        return res;
    }
}
```

## 162. 寻找峰值

- 峰值元素是指其值大于左右相邻值的元素。

```
class Solution {
    // 题目已经要求相邻的数是不相等了
    // 所以相邻的数只有两种情况：
    // nums[mid] > nums[mid + 1] 或 nums[mid] < nums[mid + 1]
    public int findPeakElement(int[] nums) {
        int left = 0;
	int right = nums.length - 1;
	while(left < right) {
		int mid = (left + right) / 2;
		if(nums[mid] > nums[mid + 1]) {  // 左边高，说明左边有峰值，可能mid就是
			right = mid;             // mid在下一次查找中还要考虑在内
		}else {
			left = mid + 1;   // 右边高，说明在mid右边有峰值，所以mid一定不是
		}                         // mid已经不是了，排除掉
	}
	return left;
    }
}
```

## 221. 最大正方形

- 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积

```
public int maximalSquare(char[][] matrix) {
        /**
        dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长, 则递推式为: 
        dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);
        **/
        int m = matrix.length;
        if(m < 1) return 0;
        int n = matrix[0].length;
        int max = 0;
        int[][] dp = new int[m+1][n+1];
        
        for(int i = 1; i <= m; ++i) {
            for(int j = 1; j <= n; ++j) {
                if(matrix[i-1][j-1] == '1') {
                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]));
                    max = Math.max(max, dp[i][j]); 
                }
            }
        }
        
        return max*max;
    }
```

## 328. 奇偶链表

```
public ListNode oddEvenList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        // head 为奇链表头结点，o 为奇链表尾节点
        ListNode o = head;
        // p 为偶链表头结点
        ListNode p = head.next;
        // e 为偶链表尾节点
        ListNode e = p;
        while (o.next != null && e.next != null) {
            o.next = e.next;
            o = o.next;
            e.next = o.next;
            e = e.next;
        }
        o.next = p;
        return head;
    }
```

