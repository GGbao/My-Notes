# 位运算
- **左移，后空缺自动补0；**
- **右移，分为逻辑右移和算数右移**
- **1）逻辑右移 不管是什么类型，空缺自动补0；**
- **2）算数右移 若是无符号数，则空缺补0，若是负数，空缺补1；**

## 15. 二进制中1的个数
**请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。**
**例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2**

- **思路：根据 与运算 定义，设二进制数字 n，则有：**
          **若 n&1=0 ，则 n 二进制 最右一位 为 0 ；因为1除了最后一位各位都为0**
          **若 n&1=1 ，则 n 二进制 最右一位 为 1 。**

- **Java中无符号右移    >>>**
- **把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把原整数的二进制表示形式的最右边的1变成0**

```java

    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res = 0;
        while (n != 0) {
            res += n & 1;
            n >>>= 1;
        }
        return res;

    }

```
- **求负数的二进制的步骤：给定一个数，比如 12，我们能求得它的二进制 1100，如何求 −12 的二进制？**
  **实际上二进制前面有个符号位，正数前面符号位是 0，负数前面符号位是 1，12 的二进制实际上是 01100，**
  **那么求 −12 的二进制有两步：**

  **1）首先把符号位从 0 改成 1，然后对 12 每位取反。变成 10011**
  **2）最后 +1，即 10011+1 = 10100，这就是 −12 的二进制**


## 56：数组中只出现一次的两个数字
**题目要求：**
**一个整数数组里除了两个数字出现一次，其他数字都出现两次。请找出这两个数字。要求时间复杂度为o(n)，空间复杂度为o(1)。**

- **异或：位数上不相同为1**

- **思路：1、全体异或以后得到的得到的数temp，因为有两个数不相同则异或肯定不为0**
      **2、求得二进制位最右边一位为1的数字**
        **3、用该位是否等于1来划分为两组，再求异或即为所求**
  
- **n&-n是求一个二进制数的最低位的1对应的数**

        设x=8
        8的二进制位：0 0 0 0 1 0 0 0
        对8取反：1 1 1 1 0 1 1 1
        取反后加1: 1 1 1 1 1 0 0 0
    
        +8:0 0 0 0 1 0 0 0
        -8:1 1 1 1 1 0 0 0
        &: 0 0 0 0 1 0 0 0
    
        lowbit = 8 & (-8) = 8

```java

    public int[] singleNumber(int[] nums) {
        int temp = nums[0];
        for (int i = 1; i < nums.length; i++) {
            temp ^= nums[i];
        }
        int[] res = new int[2];
        int lowbit = temp & -temp;
        for (int i = 0; i < nums.length; i++) {
            if ((nums[i] & lowbit) == lowbit) {//与lowbit与不变说明改位为0
                res[0] ^= nums[i];
            } else {
                res[1] ^= nums[i];
            }
        }
        return res;

    }

```

## 56 - II. 数组中数字出现的次数 II
**在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。**

- **思路：将所有数字的二进制表示的对应位都加起来，如果某一位能被三整除，那么只出现一次的数字在该位为0；反之，为1。**

```java

    public int singleNumber2(int[] nums) {
        int[] bitSum = new int[32];
        for (int i = 0; i < 32; i++) {
            bitSum[i] = 0;
        }
        for (int i = 0; i < nums.length; i++) {
            int bitMask = 1;
            for (int j = 31; j >= 0; j--) {
                int bit = nums[i] & bitMask;//注意nums[i]&bitMask不一定等于1或者0，有可能等于00010000
                if (bit != 0) {
                    bitSum[j]++;
                }
                bitMask <<= 1;
            }
        }
        int result = 0;
        for (int i = 0; i < 32; i++) {
            result = result << 1;
            result += (bitSum[i] % 3);
        }
        return result;
    }

```

- **收获**
**1.判断某个数x的第n位（如第3位）上是否为1，**

    **1）通过 x&00000100 的结果是否为0 来判断。（不能根据是否等于1来判断）**

    **2）通过（x>>3)&1 是否为0 来判断**
  
  **2.通过number&bitMask的结果是否为0（不能用1判断），bitMask=1不断左移，可以将一个数的二进制存储到32位的数组中。**

```
        int number=100;
        int bitMask=1;
        for(int j=31;j>=0;j--) {
            int bit=number&bitMask;  //注意arr[i]&bitMask不一定等于1或者0，有可能等于00010000
            if(bit!=0)
                bits[j]=1;
            bitMask=bitMask<<1;
        }
```


​	**3.通过以下代码实现二进制转化为数字（注意左移语句的位置）：**

​      

```
  		int result=0;
        for(int i=0;i<32;i++) {
            result=result<<1;
            result+=bits[i];
            //result=result<<1;  //不能放在后面，否则最前面一位就没了
        }
```



## 65. 不用加减乘除做加法
**写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。**

- **解题思路：不能用四则运算，那只能通过位运算了。**
**其实四则运算是针对十进制，位运算是针对二进制，都能用于运算。**

    **1.两数进行异或：  0011^0101=0110 这个数字其实是把原数中不需进位的二进制位进行了组合**
    **2.两数进行与：    0011&0101=0001 这个数字为1的位置表示需要进位，而进位动作是需要向前一位进位**
    **3.左移一位：      0001<<1=0010**
    **此时我们就完成0011 + 0101 = 0110 + 0010的转换**
    **如此转换下去，直到其中一个数字为0时，另一个数字就是原来的两个数字的和**


```java

    public int add(int a, int b) {
        int sum = a ^ b;
        int carry = (a & b) << 1;
        int temp;
        while (carry != 0) {
            temp = sum;
            sum = temp ^ carry;
            carry = (temp & carry) << 1;
        }
        return sum;

    }

```

* **不使用新的变量完成交换两个原有变量的值**

*  **基于加减法**
    
    ```
    int a = 3;
    int b = 5;
    a = a + b;
b = a - b;
  a = a - b;
  ```
  
  **基于异或法**
  
  ```
    a = 3;
    b = 5;
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
  ```
  
  